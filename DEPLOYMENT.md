# Deployment Guide for Goose Slackbot

This guide provides comprehensive instructions for deploying the Goose Slackbot application in various environments.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Environment Setup](#environment-setup)
3. [Docker Deployment](#docker-deployment)
4. [Kubernetes Deployment](#kubernetes-deployment)
5. [Production Deployment](#production-deployment)
6. [Health Checks](#health-checks)
7. [Monitoring](#monitoring)
8. [Troubleshooting](#troubleshooting)

## Prerequisites

### Required Software

- **Docker**: Version 20.10 or higher
- **Docker Compose**: Version 2.0 or higher
- **Python**: Version 3.11 or higher (for local development)
- **kubectl**: Latest version (for Kubernetes deployment)
- **Git**: For version control

### Required Credentials

Before deployment, ensure you have:

1. **Slack App Credentials**:
   - Bot Token (`xoxb-...`)
   - App Token (`xapp-...`)
   - Signing Secret
   - Admin Channel ID (optional)

2. **Database Credentials**:
   - PostgreSQL connection string
   - Redis connection string

3. **Snowflake Credentials** (if using):
   - Account name
   - Username and password
   - Warehouse, database, and schema names

4. **Security Keys**:
   - JWT secret key
   - Encryption key

## Environment Setup

### 1. Initial Setup

Run the environment setup script:

```bash
./scripts/setup-env.sh
```

This script will:
- Create `.env` file from template
- Generate secure random secrets
- Setup Python virtual environment
- Create necessary directories
- Setup Git hooks

### 2. Configure Environment Variables

Edit the `.env` file and update the following required variables:

```bash
# Slack Configuration
SLACK_BOT_TOKEN=xoxb-your-actual-token
SLACK_APP_TOKEN=xapp-your-actual-token
SLACK_SIGNING_SECRET=your-actual-secret

# Security (auto-generated, but verify)
JWT_SECRET_KEY=<auto-generated>
ENCRYPTION_KEY=<auto-generated>

# Database (auto-generated passwords)
POSTGRES_PASSWORD=<auto-generated>
REDIS_PASSWORD=<auto-generated>

# Snowflake (if using)
SNOWFLAKE_ACCOUNT=your-account
SNOWFLAKE_USER=your-user
SNOWFLAKE_PASSWORD=your-password
```

### 3. Verify Configuration

```bash
# Check environment file
cat .env | grep -v "PASSWORD\|SECRET\|KEY"

# Validate configuration
python -c "from config import validate_required_settings; validate_required_settings()"
```

## Docker Deployment

### Development Deployment

Deploy in development mode with hot-reload:

```bash
./scripts/deploy-docker.sh deploy dev
```

This will:
- Build Docker images
- Start all services (app, PostgreSQL, Redis)
- Run database migrations
- Perform health checks

### Production Deployment

Deploy in production mode:

```bash
./scripts/deploy-docker.sh deploy prod
```

This uses the production Docker Compose configuration with:
- Optimized images
- Resource limits
- Full monitoring stack (Prometheus, Grafana)
- Automated backups

### Common Docker Commands

```bash
# View service status
./scripts/deploy-docker.sh status

# View logs
./scripts/deploy-docker.sh logs app
./scripts/deploy-docker.sh logs postgres

# Restart services
./scripts/deploy-docker.sh restart

# Stop services
./scripts/deploy-docker.sh stop

# Backup database
./scripts/deploy-docker.sh backup

# Restore database
./scripts/deploy-docker.sh restore /path/to/backup.sql

# Clean up (removes volumes)
./scripts/deploy-docker.sh clean
```

### Accessing Services

After deployment:

- **Application**: http://localhost:3000
- **Health Check**: http://localhost:3000/health
- **Metrics**: http://localhost:9090
- **Grafana**: http://localhost:3001 (admin/admin)
- **Prometheus**: http://localhost:9091

## Kubernetes Deployment

### 1. Prepare Cluster

Ensure you have a Kubernetes cluster and `kubectl` is configured:

```bash
kubectl cluster-info
kubectl get nodes
```

### 2. Build and Push Image

If using a container registry:

```bash
export DOCKER_REGISTRY=your-registry.io
export IMAGE_TAG=v1.0.0

./scripts/deploy-k8s.sh build
```

### 3. Deploy to Kubernetes

Full deployment:

```bash
./scripts/deploy-k8s.sh deploy
```

This will:
- Create namespace
- Create secrets from `.env` file
- Build and push Docker image
- Apply all Kubernetes manifests
- Wait for deployment to be ready
- Run health checks

### 4. Verify Deployment

```bash
# Check deployment status
./scripts/deploy-k8s.sh status

# View logs
./scripts/deploy-k8s.sh logs app

# Run health checks
./scripts/deploy-k8s.sh health
```

### 5. Access Application

Port forward to access locally:

```bash
./scripts/deploy-k8s.sh port-forward
```

Then access at http://localhost:3000

### Kubernetes Management Commands

```bash
# Scale deployment
./scripts/deploy-k8s.sh scale 5

# Rollback deployment
./scripts/deploy-k8s.sh rollback

# Delete all resources
./scripts/deploy-k8s.sh delete

# Apply manifests only (no build)
./scripts/deploy-k8s.sh apply
```

## Production Deployment

### Pre-Deployment Checklist

- [ ] All environment variables configured
- [ ] Secrets properly secured (use secret management tools)
- [ ] Database backups configured
- [ ] Monitoring and alerting setup
- [ ] SSL/TLS certificates configured (if using Ingress)
- [ ] Resource limits reviewed and adjusted
- [ ] High availability configured (multiple replicas)
- [ ] Disaster recovery plan documented

### Production Best Practices

#### 1. Use Secret Management

Instead of `.env` files, use:

**Kubernetes Secrets:**
```bash
kubectl create secret generic goose-slackbot-secrets \
  --from-literal=SLACK_BOT_TOKEN=$SLACK_BOT_TOKEN \
  --from-literal=SLACK_APP_TOKEN=$SLACK_APP_TOKEN \
  --namespace=goose-slackbot
```

**Or use external secret managers:**
- AWS Secrets Manager
- HashiCorp Vault
- Azure Key Vault
- Google Secret Manager

#### 2. Configure Resource Limits

Edit `k8s/deployment-complete.yaml`:

```yaml
resources:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi
```

#### 3. Setup Horizontal Pod Autoscaling

Already configured in `k8s/deployment-complete.yaml`:

```yaml
minReplicas: 3
maxReplicas: 10
targetCPUUtilizationPercentage: 70
```

#### 4. Configure Ingress

Update `k8s/ingress.yaml` with your domain:

```yaml
spec:
  rules:
  - host: goose-slackbot.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: goose-slackbot-service
            port:
              number: 3000
```

#### 5. Setup SSL/TLS

Use cert-manager for automatic certificate management:

```bash
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
```

Update ingress with TLS configuration:

```yaml
spec:
  tls:
  - hosts:
    - goose-slackbot.yourdomain.com
    secretName: goose-slackbot-tls
```

#### 6. Configure Backups

Automated backups are configured in `docker-compose.prod.yml`:

```yaml
backup:
  environment:
    BACKUP_SCHEDULE: "0 2 * * *"  # Daily at 2 AM
```

For Kubernetes, setup CronJob:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
spec:
  schedule: "0 2 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: postgres:15-alpine
            command: ["/bin/sh", "-c"]
            args:
            - pg_dump -h postgres-service -U goose_user goose_slackbot | gzip > /backups/backup-$(date +%Y%m%d-%H%M%S).sql.gz
```

## Health Checks

### Health Check Endpoints

The application provides three health check endpoints:

1. **Liveness Probe** (`/live`): Checks if the application is alive
2. **Readiness Probe** (`/ready`): Checks if the application is ready to serve traffic
3. **Full Health Check** (`/health`): Comprehensive health check of all components

### Manual Health Check

```bash
# Using curl
curl http://localhost:3000/health

# Using the health check script
python health_check.py --check health --json

# Exit with error code if unhealthy
python health_check.py --check health --exit-code
```

### Kubernetes Health Checks

Already configured in deployment:

```yaml
livenessProbe:
  httpGet:
    path: /live
    port: 3000
  initialDelaySeconds: 60
  periodSeconds: 30

readinessProbe:
  httpGet:
    path: /ready
    port: 3000
  initialDelaySeconds: 30
  periodSeconds: 10

startupProbe:
  httpGet:
    path: /health
    port: 3000
  failureThreshold: 30
  periodSeconds: 10
```

## Monitoring

### Prometheus Metrics

Metrics are exposed at `http://localhost:9090/metrics`

Key metrics:
- `http_requests_total`: Total HTTP requests
- `http_request_duration_seconds`: Request duration
- `goose_queries_total`: Total queries processed
- `goose_queries_failed_total`: Failed queries
- `slack_api_calls_total`: Slack API calls
- `database_connections`: Active database connections

### Grafana Dashboards

Access Grafana at http://localhost:3001

Default credentials:
- Username: `admin`
- Password: `admin` (change on first login)

Pre-configured dashboards:
- Application Overview
- Database Performance
- System Resources
- Slack API Metrics

### Alerting

Alerts are configured in `monitoring/alerts.yml`

Key alerts:
- Application Down
- High Error Rate
- Database Connection Issues
- High Memory/CPU Usage
- Slow Query Performance

Configure AlertManager webhook in `monitoring/alertmanager.yml`:

```yaml
global:
  slack_api_url: 'YOUR_SLACK_WEBHOOK_URL'
```

## Troubleshooting

### Common Issues

#### 1. Application Won't Start

**Check logs:**
```bash
# Docker
docker-compose logs app

# Kubernetes
kubectl logs -n goose-slackbot -l component=app
```

**Common causes:**
- Missing environment variables
- Database connection failure
- Redis connection failure
- Invalid Slack credentials

#### 2. Database Connection Errors

**Check database status:**
```bash
# Docker
docker-compose exec postgres pg_isready -U goose_user

# Kubernetes
kubectl exec -n goose-slackbot postgres-0 -- pg_isready
```

**Verify connection string:**
```bash
echo $DATABASE_URL
```

#### 3. Slack API Errors

**Verify credentials:**
- Check token format (xoxb- for bot token)
- Verify token has required scopes
- Check signing secret matches

**Test Slack connection:**
```python
from slack_sdk import WebClient
client = WebClient(token="your-token")
response = client.auth_test()
print(response)
```

#### 4. High Memory Usage

**Check resource usage:**
```bash
# Docker
docker stats

# Kubernetes
kubectl top pods -n goose-slackbot
```

**Adjust resource limits:**
Edit `docker-compose.prod.yml` or `k8s/deployment-complete.yaml`

#### 5. Slow Performance

**Check metrics:**
- Query execution times
- Database connection pool
- Redis cache hit rate
- API response times

**Optimize:**
- Increase worker count
- Scale horizontally (more replicas)
- Optimize database queries
- Increase cache TTL

### Debug Mode

Enable debug mode for verbose logging:

```bash
# In .env file
DEBUG=true
LOG_LEVEL=DEBUG

# Restart application
./scripts/deploy-docker.sh restart
```

### Support

For additional help:
1. Check logs: `./scripts/deploy-docker.sh logs`
2. Run health checks: `./scripts/deploy-docker.sh health`
3. Review documentation: `README.md`, `ADMIN_GUIDE.md`
4. Check monitoring dashboards

## Rollback Procedure

### Docker

```bash
# Stop current deployment
./scripts/deploy-docker.sh stop

# Restore from backup
./scripts/deploy-docker.sh restore /path/to/backup.sql

# Start previous version
git checkout <previous-tag>
./scripts/deploy-docker.sh deploy prod
```

### Kubernetes

```bash
# Rollback deployment
./scripts/deploy-k8s.sh rollback

# Or manually
kubectl rollout undo deployment/goose-slackbot-app -n goose-slackbot

# Check rollout status
kubectl rollout status deployment/goose-slackbot-app -n goose-slackbot
```

## Maintenance

### Regular Maintenance Tasks

1. **Database Backups**: Automated daily (configured)
2. **Log Rotation**: Configured in Docker/K8s
3. **Security Updates**: Update base images monthly
4. **Dependency Updates**: Review and update quarterly
5. **Performance Review**: Monthly metrics review
6. **Capacity Planning**: Quarterly resource review

### Upgrade Procedure

1. **Backup current state:**
   ```bash
   ./scripts/deploy-docker.sh backup
   ```

2. **Test in staging:**
   ```bash
   ENVIRONMENT=staging ./scripts/deploy-docker.sh deploy
   ```

3. **Deploy to production:**
   ```bash
   ./scripts/deploy-docker.sh deploy prod
   ```

4. **Verify deployment:**
   ```bash
   ./scripts/deploy-docker.sh health
   ./scripts/deploy-docker.sh status
   ```

5. **Monitor for issues:**
   - Check Grafana dashboards
   - Review application logs
   - Monitor error rates

## Security Considerations

1. **Secrets Management**: Never commit secrets to git
2. **Network Security**: Use network policies in Kubernetes
3. **Access Control**: Implement RBAC
4. **Encryption**: Use TLS for all communications
5. **Audit Logging**: Enable audit logs
6. **Regular Updates**: Keep dependencies updated
7. **Vulnerability Scanning**: Run security scans regularly

## Additional Resources

- [README.md](README.md) - Project overview
- [SETUP.md](SETUP.md) - Initial setup guide
- [ADMIN_GUIDE.md](ADMIN_GUIDE.md) - Administration guide
- [TROUBLESHOOTING.md](TROUBLESHOOTING.md) - Detailed troubleshooting
- [API.md](API.md) - API documentation

## Support and Feedback

For issues or questions:
1. Check existing documentation
2. Review logs and metrics
3. Consult troubleshooting guide
4. Contact development team
